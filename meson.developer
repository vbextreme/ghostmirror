#!/bin/perl -w

use strict;
use warnings;
use JSON::PP;
use Data::Dumper;
use File::Find;
use POSIX qw(strftime);

my $PRJPATH = "";
if( defined $ENV{MESON_SOURCE_ROOT} ){
	$PRJPATH = $ENV{MESON_SOURCE_ROOT};
}
else{
	$PRJPATH = git_path();
}

my $BUILD_PATH="${PRJPATH}/build";
my $BUILD_OPTIONS='';
my $DESC='';
my $BRANCH='main';
my @EXTRAFILES = (
	"${PRJPATH}/meson.build",
	"${PRJPATH}/meson.options",
	"${PRJPATH}/meson.developer",
);
my @MAKEDEPENDS = (
	"meson",
	"perl",
	"ninja"
);
my @DEPENDS = ();

sub uniq {
	my %seen;
	grep !$seen{$_}++, @_;
}

sub merge_basharray{
	my( $r ) = @_;
	my $ret = '(';
	for my $e (@$r){
		$ret .= "'$e' ";
	}
	chop $ret if scalar @$r;
	return $ret . ")";
}

sub acheckstr{
	my ($arr, $f) = @_;
	for my $e (@$arr){
		return 1 if $e eq $f;
	}
	return 0;
}

sub meson_introspect{
	my ($build) = @_;
	my $jsintrospect = `meson introspect $build -a`;
	die "fail introspect" if $?;
	return decode_json($jsintrospect);
}

sub meson_introspect_find_headers{
	my ($mi) = @_;
	my $para = $mi->{'targets'}->[0]->{'target_sources'}->[0]->{'parameters'};
	my @ret;
	for my $p (@$para){
		if( $p =~ /^-I(.*)/ ){
			find(
				{
					wanted => sub{
						my $fname = $File::Find::name;
					    push @ret, $fname if $fname =~ /\.h$/;
					},
					no_chdir =>1
				},
				$1
			);
		}
	}
	my @arr = uniq(@ret);
	return \@arr;
}

sub git_path{
	my $p=`git rev-parse --show-toplevel`;
	die "fail git rev-parse --show-toplevel" if $?;
	(my $r=$p) =~ s/\n//;
	return $r;
}

sub git_lstree{
	my ($branch, $path) = @_;
	my $br = `git -C $path ls-tree -r --name-only $branch`;
	die "fail git ls-tree" if $?;
	my @relfiles = split /\n/, $br;
	my @absfiles;
	for my $f (@relfiles){
		push @absfiles, "${path}/${f}";
	}
	return \@absfiles;
}

sub git_commit{
	my ($path, $desc) = @_;
	die "fail git commit" if system("git -C $path commit -a -m '$desc'");
}

sub git_push_newversion{
	my ($path, $ver) = @_;
	die "fail git tag" if system("git -C $path tag -a v$ver -m 'v$ver'");
	die "fail git push" if system("git -C $path push --follow-tags");
}

sub git_push{
	my ($path, $ver) = @_;
	die "fail git push" if system("git -C $path push");
}

sub git_aur{
	my ($path, $prjname, $desc) = @_;
	die "fail git commit" if system("git -C $path/distro/$prjname commit -a -m '$desc'");
	die "fail git push" if system("git -C $path/distro/$prjname push");
}

sub readme_version{
	my ($path, $prjname) = @_;
	open my $f, '<', "${path}/README.md" or die("Could not open README.md");
	while( my $l = <$f>){
		return $1 if $l =~ /$prjname v([0-9\.]+)/;
	}
	return "";
}

sub readme_update_version{
	my ($path, $prjname, $prjversion) = @_;
	open my $fh, "${path}/README.md" or die("Could not open README.md");
	my $md = do { local $/; <$fh> };
	close $fh;
	(my $rep0 = $md) =~ s/\Q$prjname\E v[0-9.]+/$prjname v$prjversion/;
	open my $fo, '>', "${path}/README.md" or die("Could not open README.md");
	print $fo $rep0;
	close $fo;
}

sub update_manpage{
	my ($path, $newversion) = @_;
	(my $ver = $newversion) =~ s/\./&\./g;
	my $curdate = strftime "%d %b %Y", localtime;
	$path .= '/man';
	find(
		{
			wanted => sub{
				my $fname = $File::Find::name;
				if( $fname =~ /\.[0-9]+\.skel$/ ){
					open my $fh, '<', $fname or die("Could not open $fname");
					my $skel = do { local $/; <$fh> };
					close $fh;
					(my $rep0 = $skel) =~ s/:CURRENT_DATE:/$curdate/;
					(my $rep1 = $rep0) =~ s/:CURRENT_VERSION:/$ver/;
					(my $fout = $fname)=~ s/\.skel$//;
					open my $fo, '>', $fout or die("Could not open $fout");
					print $fo $rep1;
					close $fo;
				}
			},
			no_chdir =>1
		},
		$path
	);
}

sub check_commit_projects_file{
	my ($gitfiles, $src, $headers, $extra) = @_;
	for my $s (@$src){
		die "file $s in not add in git branch" unless acheckstr($gitfiles, $s);
	}
	for my $h (@$headers){
		die "header $h in not add in git branch" unless acheckstr($gitfiles, $h);
	}
	for my $e (@$extra){
		die "extra $e in not add in git branch" unless acheckstr($gitfiles, $e);
	}
}

sub update_pkgbuild_sha{
	my ($path, $prjname) = @_;
	my $fname = "$path/distro/$prjname/PKGBUILD";
	return if !(-e $fname);
	open my $fh, '<', $fname or die("Could not open $fname");
	my $pkgbuild = do { local $/; <$fh> };
	close $fh;
	my $sha = `cd $path/distro/$prjname && makepkg -g 2>/dev/null`;
	chomp $sha;
	system("rm $path/distro/$prjname/*.tar.gz");
	(my $rep0 = $pkgbuild) =~ s/^sha256sums=.*/$sha/m;
	open my $fo, '>', $fname or die("Could not open $fname");
	print $fo $rep0;
	close $fo;
}

sub update_pkgbuild{
	my ($path,  $newversion, $mkdep, $dep) = @_;
	my $fname = "$path/distro/PKGBUILD";
	return if !(-e $fname);
	open my $fh, '<', $fname or die("Could not open $fname");
	my $pkgbuild = do { local $/; <$fh> };
	close $fh;
	my $strmkdeps = merge_basharray($mkdep);
	my $strdeps   = merge_basharray($dep);
	(my $rep0 = $pkgbuild) =~ s/^pkgver=.*/pkgver='$newversion'/m;
	(my $rep1 = $rep0) =~ s/^makedepends\=.*/makedepends=$strmkdeps/m;
	(my $rep2 = $rep1) =~ s/^depends\=.*/depends=$strdeps/m;
	open my $fo, '>', $fname or die("Could not open $fname");
	print $fo $rep2;
	close $fo;
}

sub make_pkgbuild{
	my ($path, $prjname, $desc) = @_;
	my $fname = "$path/distro/PKGBUILD";
	return if !(-e $fname);
	my $rppath = "$path/distro/$prjname/PKGBUILD";
	return if !(-e $rppath);
	die "fail copy PKGBUILD" if system("cp $fname $rppath");
	update_pkgbuild_sha($path, $prjname);
	die "fail makepkg" if system("cd $path/distro/$prjname && makepkg --printsrcinfo > ./.SRCINFO");
	git_aur($path, $prjname, $desc);
}

while( (my $arg = shift @ARGV) ){
	if( $arg eq '-b' ){
		$BUILD_PATH = shift @ARGV;
	}
	elsif( $arg eq '-o' ){
		$BUILD_OPTIONS = shift @ARGV;
	}
	elsif( $arg eq '-B' ){
		$BRANCH = shift @ARGV;
	}
	elsif( $arg eq '-e' ){
		push @EXTRAFILES, shift @ARGV;
	}
	elsif( $arg eq '-m' ){
		push @MAKEDEPENDS, shift @ARGV;
	}
	elsif( $arg eq '-d' ){
		push @DEPENDS, shift @ARGV;
	}
	elsif( $arg eq '-D' ){
		$DESC = shift @ARGV;
	}
}
die "missing desctiption" if $DESC eq '';

if( !(-d $BUILD_PATH) ){
	die "fail to build project" if system("meson setup $BUILD_PATH $BUILD_OPTIONS");
}

my $mi = meson_introspect($BUILD_PATH);
#print Dumper($mi);

my $prjname    = $mi->{'projectinfo'}->{'descriptive_name'};
my $prjversion = $mi->{'projectinfo'}->{'version'};
#die($prjversion);
my $versionmd  = readme_version($PRJPATH, $prjname);

if( $prjversion ne $versionmd ){
	my $sources = $mi->{'targets'}->[0]->{'target_sources'}->[0]->{'sources'};
	print "meson introspect\n";
	my $headers = meson_introspect_find_headers($mi);
	print "lstree\n";
	my $files = git_lstree($BRANCH, $PRJPATH);
	#print Dumper($files);
	print "update man page\n";
	update_manpage($PRJPATH, $prjversion);
	print "update readme\n";
	readme_update_version($PRJPATH, $prjname, $prjversion);
	print "update pkgbuild\n";
	update_pkgbuild($PRJPATH, $prjversion, \@MAKEDEPENDS, \@DEPENDS);
	print "git commit\n";
	git_commit($PRJPATH, $DESC);
	print "check commit\n";
	check_commit_projects_file($files, $sources, $headers, \@EXTRAFILES);
	print "push version\n";
	git_push_newversion($PRJPATH, $prjversion);
	print "aur update\n";
	make_pkgbuild($PRJPATH, $prjname, $DESC);
	print "meson.developer: update successfull\n";
}
else{
	print "meson.developer: not need update\n";
}
exit 0;
